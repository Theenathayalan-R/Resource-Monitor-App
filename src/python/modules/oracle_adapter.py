"""
Oracle Database adapter for Spark Pod Resource Monitor
Provides Oracle-specific database operations with connection pooling
"""
import logging
from typing import List, Tuple, Optional, Dict, Any
from contextlib import contextmanager
from datetime import datetime, timedelta

try:
    import oracledb
    ORACLE_AVAILABLE = True
    OracleError = oracledb.Error
except ImportError:
    ORACLE_AVAILABLE = False
    oracledb = None
    OracleError = Exception  # Fallback for type hints

from logging_config import DatabaseError


class OracleAdapter:
    """Oracle database adapter with connection pooling"""
    
    def __init__(self, host: str, port: int, service_name: str, username: str, 
                 password: str, max_connections: int = 10):
        if not ORACLE_AVAILABLE:
            raise DatabaseError(
                "oracledb not available. Install with: pip install oracledb"
            )
        
        self.host = host
        self.port = port
        self.service_name = service_name
        self.username = username
        self.password = password
        self.max_connections = max_connections
        
        # Create connection pool
        self.pool = None
        self.logger = logging.getLogger(__name__)
        
        self._create_connection_pool()
        self._init_database()
    
    def _create_connection_pool(self):
        """Create Oracle connection pool"""
        if not oracledb:
            raise DatabaseError("oracledb not available")
            
        try:
            dsn = oracledb.makedsn(self.host, self.port, service_name=self.service_name)
            self.pool = oracledb.create_pool(
                user=self.username,
                password=self.password,
                dsn=dsn,
                min=2,
                max=self.max_connections,
                increment=1
            )
            self.logger.info(f"Created Oracle connection pool: {self.host}:{self.port}/{self.service_name}")
        except OracleError as e:
            raise DatabaseError(f"Failed to create Oracle connection pool: {str(e)}")
    
    @contextmanager
    def _get_connection(self):
        """Context manager for Oracle database connections"""
        conn = None
        try:
            if oracledb and self.pool:
                conn = self.pool.acquire()
            else:
                raise DatabaseError("oracledb not available or pool not initialized")
            yield conn
        except OracleError as e:
            if conn:
                conn.rollback()
            self.logger.error(f"Oracle database error: {str(e)}", exc_info=True)
            raise DatabaseError(f"Oracle operation failed: {str(e)}")
        except Exception as e:
            if conn:
                conn.rollback()
            self.logger.error(f"Unexpected error in Oracle operation: {str(e)}", exc_info=True)
            raise DatabaseError(f"Unexpected Oracle error: {str(e)}")
        finally:
            if conn and oracledb and self.pool:
                self.pool.release(conn)
    
    def _init_database(self):
        """Initialize Oracle database schema"""
        try:
            with self._get_connection() as conn:
                cursor = conn.cursor()
                
                # Create main pod_history table
                cursor.execute('''
                    BEGIN
                        EXECUTE IMMEDIATE 'DROP TABLE pod_history CASCADE CONSTRAINTS';
                    EXCEPTION
                        WHEN OTHERS THEN
                            IF SQLCODE != -942 THEN  -- Table doesn't exist
                                RAISE;
                            END IF;
                    END;
                ''')
                
                cursor.execute('''
                    CREATE TABLE pod_history (
                        id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        namespace VARCHAR2(100) NOT NULL,
                        pod_name VARCHAR2(255) NOT NULL,
                        app_name VARCHAR2(255),
                        pod_type VARCHAR2(50),
                        status VARCHAR2(50),
                        cpu_usage NUMBER(10,6),
                        memory_usage NUMBER(12,2),
                        cpu_limit NUMBER(10,6),
                        memory_limit NUMBER(12,2),
                        cpu_requests NUMBER(10,6),
                        memory_requests NUMBER(12,2),
                        is_active NUMBER(1) DEFAULT 1,
                        node_name VARCHAR2(255),
                        created_at TIMESTAMP,
                        started_at TIMESTAMP,
                        metadata CLOB
                    )
                ''')
                
                # Create indexes for performance
                indexes = [
                    'CREATE INDEX idx_pod_history_timestamp ON pod_history(timestamp)',
                    'CREATE INDEX idx_pod_history_namespace ON pod_history(namespace)',
                    'CREATE INDEX idx_pod_history_pod_name ON pod_history(pod_name)',
                    'CREATE INDEX idx_pod_history_app_name ON pod_history(app_name)',
                    'CREATE INDEX idx_pod_history_active ON pod_history(is_active)',
                    'CREATE INDEX idx_pod_history_ns_pod ON pod_history(namespace, pod_name)',
                    'CREATE INDEX idx_pod_history_ns_app ON pod_history(namespace, app_name)',
                ]
                
                for index_sql in indexes:
                    try:
                        cursor.execute(index_sql)
                    except OracleError as e:
                        if 'ORA-00955' not in str(e):  # Index already exists
                            raise
                
                conn.commit()
                self.logger.info("Oracle database schema initialized successfully")
                
        except Exception as e:
            raise DatabaseError(f"Failed to initialize Oracle database: {str(e)}")
    
    def store_pod_data(self, namespace: str, pod_data: Dict[str, Any]) -> bool:
        """Store pod data in Oracle database"""
        try:
            with self._get_connection() as conn:
                cursor = conn.cursor()
                
                # Convert datetime objects to Oracle format
                created_at = None
                started_at = None
                
                if 'created_at' in pod_data and pod_data['created_at']:
                    if isinstance(pod_data['created_at'], str):
                        created_at = datetime.fromisoformat(pod_data['created_at'].replace('Z', '+00:00'))
                    else:
                        created_at = pod_data['created_at']
                
                if 'started_at' in pod_data and pod_data['started_at']:
                    if isinstance(pod_data['started_at'], str):
                        started_at = datetime.fromisoformat(pod_data['started_at'].replace('Z', '+00:00'))
                    else:
                        started_at = pod_data['started_at']
                
                cursor.execute('''
                    INSERT INTO pod_history 
                    (namespace, pod_name, app_name, pod_type, status, cpu_usage, memory_usage,
                     cpu_limit, memory_limit, cpu_requests, memory_requests, is_active,
                     node_name, created_at, started_at, metadata)
                    VALUES (:1, :2, :3, :4, :5, :6, :7, :8, :9, :10, :11, :12, :13, :14, :15, :16)
                ''', (
                    namespace,
                    pod_data.get('pod_name'),
                    pod_data.get('app_name'),
                    pod_data.get('pod_type'),
                    pod_data.get('status'),
                    pod_data.get('cpu_usage'),
                    pod_data.get('memory_usage'),
                    pod_data.get('cpu_limit'),
                    pod_data.get('memory_limit'),
                    pod_data.get('cpu_requests'),
                    pod_data.get('memory_requests'),
                    1 if pod_data.get('is_active', True) else 0,
                    pod_data.get('node_name'),
                    created_at,
                    started_at,
                    pod_data.get('metadata', '{}')
                ))
                
                conn.commit()
                return True
                
        except Exception as e:
            self.logger.error(f"Failed to store pod data: {str(e)}", exc_info=True)
            return False
    
    def store_pod_data_batch(self, namespace: str, pods_data: List[Dict[str, Any]]) -> int:
        """Store multiple pod records in batch"""
        if not pods_data:
            return 0
        
        try:
            with self._get_connection() as conn:
                cursor = conn.cursor()
                
                # Prepare batch data
                batch_data = []
                for pod_data in pods_data:
                    created_at = None
                    started_at = None
                    
                    if 'created_at' in pod_data and pod_data['created_at']:
                        if isinstance(pod_data['created_at'], str):
                            created_at = datetime.fromisoformat(pod_data['created_at'].replace('Z', '+00:00'))
                        else:
                            created_at = pod_data['created_at']
                    
                    if 'started_at' in pod_data and pod_data['started_at']:
                        if isinstance(pod_data['started_at'], str):
                            started_at = datetime.fromisoformat(pod_data['started_at'].replace('Z', '+00:00'))
                        else:
                            started_at = pod_data['started_at']
                    
                    batch_data.append((
                        namespace,
                        pod_data.get('pod_name'),
                        pod_data.get('app_name'),
                        pod_data.get('pod_type'),
                        pod_data.get('status'),
                        pod_data.get('cpu_usage'),
                        pod_data.get('memory_usage'),
                        pod_data.get('cpu_limit'),
                        pod_data.get('memory_limit'),
                        pod_data.get('cpu_requests'),
                        pod_data.get('memory_requests'),
                        1 if pod_data.get('is_active', True) else 0,
                        pod_data.get('node_name'),
                        created_at,
                        started_at,
                        pod_data.get('metadata', '{}')
                    ))
                
                cursor.executemany('''
                    INSERT INTO pod_history 
                    (namespace, pod_name, app_name, pod_type, status, cpu_usage, memory_usage,
                     cpu_limit, memory_limit, cpu_requests, memory_requests, is_active,
                     node_name, created_at, started_at, metadata)
                    VALUES (:1, :2, :3, :4, :5, :6, :7, :8, :9, :10, :11, :12, :13, :14, :15, :16)
                ''', batch_data)
                
                conn.commit()
                return len(batch_data)
                
        except Exception as e:
            self.logger.error(f"Failed to store batch pod data: {str(e)}", exc_info=True)
            return 0
    
    def get_historical_data(self, namespace: str, hours_back: int = 24, app_filter: Optional[str] = None) -> List[Dict[str, Any]]:
        """Get historical pod data from Oracle"""
        try:
            with self._get_connection() as conn:
                cursor = conn.cursor()
                
                since_time = datetime.now() - timedelta(hours=hours_back)
                
                if app_filter:
                    cursor.execute('''
                        SELECT timestamp, namespace, pod_name, app_name, pod_type, status,
                               cpu_usage, memory_usage, cpu_limit, memory_limit,
                               cpu_requests, memory_requests, is_active, node_name,
                               created_at, started_at, metadata
                        FROM pod_history 
                        WHERE namespace = :1 AND timestamp >= :2 AND UPPER(app_name) LIKE UPPER(:3)
                        ORDER BY timestamp DESC
                    ''', (namespace, since_time, f'%{app_filter}%'))
                else:
                    cursor.execute('''
                        SELECT timestamp, namespace, pod_name, app_name, pod_type, status,
                               cpu_usage, memory_usage, cpu_limit, memory_limit,
                               cpu_requests, memory_requests, is_active, node_name,
                               created_at, started_at, metadata
                        FROM pod_history 
                        WHERE namespace = :1 AND timestamp >= :2
                        ORDER BY timestamp DESC
                    ''', (namespace, since_time))
                
                rows = cursor.fetchall()
                
                # Convert to list of dictionaries
                columns = [desc[0].lower() for desc in cursor.description]
                result = []
                
                for row in rows:
                    record = dict(zip(columns, row))
                    # Convert Oracle NUMBER(1) back to boolean
                    record['is_active'] = bool(record['is_active'])
                    result.append(record)
                
                return result
                
        except Exception as e:
            self.logger.error(f"Failed to get historical data: {str(e)}", exc_info=True)
            return []
    
    def list_pod_names(self, namespace: Optional[str] = None) -> List[str]:
        """Return distinct pod names sorted by most recent activity"""
        try:
            with self._get_connection() as conn:
                cursor = conn.cursor()
                
                if namespace:
                    cursor.execute('''
                        SELECT DISTINCT pod_name 
                        FROM pod_history 
                        WHERE namespace = :1 
                        ORDER BY (
                            SELECT MAX(timestamp) 
                            FROM pod_history ph2 
                            WHERE ph2.pod_name = pod_history.pod_name 
                            AND ph2.namespace = pod_history.namespace
                        ) DESC
                    ''', (namespace,))
                else:
                    cursor.execute('''
                        SELECT DISTINCT pod_name 
                        FROM pod_history 
                        ORDER BY (
                            SELECT MAX(timestamp) 
                            FROM pod_history ph2 
                            WHERE ph2.pod_name = pod_history.pod_name
                        ) DESC
                    ''')
                
                rows = cursor.fetchall()
                return [row[0] for row in rows]
                
        except Exception as e:
            self.logger.error(f"Failed to list pod names: {str(e)}", exc_info=True)
            return []
    
    def cleanup_old_data(self, retention_days: int = 7) -> int:
        """Clean up old pod history data"""
        try:
            with self._get_connection() as conn:
                cursor = conn.cursor()
                
                cutoff_date = datetime.now() - timedelta(days=retention_days)
                
                cursor.execute('''
                    DELETE FROM pod_history 
                    WHERE timestamp < :1
                ''', (cutoff_date,))
                
                deleted_count = cursor.rowcount
                conn.commit()
                
                self.logger.info(f"Cleaned up {deleted_count} old records (older than {retention_days} days)")
                return deleted_count
                
        except Exception as e:
            self.logger.error(f"Failed to cleanup old data: {str(e)}", exc_info=True)
            return 0
    
    def get_database_stats(self) -> Dict[str, Any]:
        """Get database statistics"""
        try:
            with self._get_connection() as conn:
                cursor = conn.cursor()
                
                cursor.execute('SELECT COUNT(*) FROM pod_history')
                total_records = cursor.fetchone()[0]
                
                cursor.execute('''
                    SELECT COUNT(DISTINCT namespace) FROM pod_history
                ''')
                namespaces_count = cursor.fetchone()[0]
                
                cursor.execute('''
                    SELECT COUNT(DISTINCT pod_name) FROM pod_history
                ''')
                unique_pods = cursor.fetchone()[0]
                
                cursor.execute('''
                    SELECT MIN(timestamp), MAX(timestamp) FROM pod_history
                ''')
                result = cursor.fetchone()
                oldest_record = result[0]
                newest_record = result[1]
                
                return {
                    'database_type': 'oracle',
                    'total_records': total_records,
                    'namespaces_count': namespaces_count,
                    'unique_pods': unique_pods,
                    'oldest_record': oldest_record.isoformat() if oldest_record else None,
                    'newest_record': newest_record.isoformat() if newest_record else None,
                    'connection_pool_size': self.max_connections
                }
                
        except Exception as e:
            self.logger.error(f"Failed to get database stats: {str(e)}", exc_info=True)
            return {
                'database_type': 'oracle',
                'error': str(e)
            }
    
    def close(self):
        """Close Oracle connection pool"""
        try:
            if self.pool:
                self.pool.close(force=True)
                self.logger.info("Oracle connection pool closed")
        except Exception as e:
            self.logger.error(f"Error closing Oracle connection pool: {str(e)}")
    
    def __del__(self):
        """Cleanup on object destruction"""
        self.close()
